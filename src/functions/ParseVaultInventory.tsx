import {
  itemObjType,
  hashArr,
  SQLResponseArr,
  SQLResponseItem,
  // vaultObjType,
  itemArrayType,
} from "../CustomTypes";

import bucketDict from "../assets/BucketDict.json";

// * takes character, equipped items and unequipped items
// * matches up hashes, ids and buckets
// * pushes the items into the correct characterObj array
// * returns updated character
async function parseCharacterInventory(
  // initialisedVault: vaultObjType,
  initialisedVault: itemArrayType | undefined,
  vaultInventory: hashArr | undefined,
  items: SQLResponseArr | undefined,
) {
  // exit if character not initialised
  if (
    !initialisedVault ||
    !vaultInventory ||
    !items
  ) {
    return undefined;
  }

  //   console.log("ðŸš€ ~ bucketDict:", bucketDict)

  try {
    for (const id of vaultInventory) {
      let itemIndex = items.findIndex(
        (element: SQLResponseItem) =>
          element.id === id.itemHash || element.id + 4294967296 === id.itemHash,
      );
      let bucketIndex = bucketDict.findIndex(
        (element: SQLResponseItem) =>
          element.id === id.bucketHash ||
          element.id + 4294967296 === id.bucketHash,
      );

      const itemResJson = JSON.parse(items[itemIndex].json);
      const bucketResJson = JSON.parse(bucketDict[bucketIndex].json);

      const itemObj: itemObjType = {
        hash: id.itemHash,
        bucketHash: id.bucketHash,
        tableId: items[itemIndex].id,
        name: itemResJson.displayProperties.name,
        icon: itemResJson.displayProperties.icon,
        flavorText: itemResJson.flavorText,
        rarity: itemResJson.inventory.tierTypeName,
        itemType: itemResJson.itemTypeDisplayName,
        bucket: bucketResJson.displayProperties.name,
        equipped: false,
        instance: "",
        itemInstanceId: id.itemInstanceId,
      };
      // console.log("ðŸš€ ~ itemObj:", itemObj)


// TODO This could be sorted by the item type instead of bucket maybe, but type wise, the item types would have
// ! to be generated by the items in the vault, but that creates headaches around not knowing what is there
// ! and therefore having to deal with it as you push and pop items into and out of the vault
      // const bucketSelect = {
      //   kineticWeapons: "Kinetic Weapons",
      //   energyWeapons: "Energy Weapons",
      //   heavyWeapons: "Power Weapons",
      //   helmet: "Helmet",
      //   arms: "Gauntlets",
      //   chest: "Chest Armor",
      //   legs: "Leg Armor",
      //   classItem: "Class Armor",
      //   ghost: "Ghost",
      //   ship: "Ships",
      //   sparrow: "Vehicle",
      //   // "inventory": "",
      // };

      // for (const [key, value] of Object.entries(bucketSelect)) {
      //   // console.log(`key: ${key}, value: ${value}`);
      //   if (itemObj.bucket === value) {
      //     key;
          // The hasharray is an array of objects, each with an itemhash and buckethash, so we just look through the array and compare the entries to the bucket
          let instance = 0;
          // if (
          //   key === "kineticWeapons" ||
          //   key === "energyWeapons" ||
          //   key === "heavyWeapons"
          //   // ||
          //   // key === "ghost" ||
          //   // key === "ship" ||
          //   // key === "sparrow"
          // ) {
          //   //   preParseData.forEach(char => {
          //     initialisedVault[key as keyof vaultObjType].forEach(
          //     (element) => {
          //       if (element.hash === itemObj.hash) {
          //         instance++;
          //       }
          //     },
          //   );
          //   //   })
          //   // TODO iterate over the vault to increase the instance count
          // } else {
            initialisedVault.forEach(
              (element) => {
                if (element.hash === itemObj.hash) {
                  instance++;
                }
                // // TODO iterate over the vault to increase the instance count
              },
            );
            // initialisedVault[key as keyof vaultObjType].forEach(
            //   (element) => {
            //     if (element.hash === itemObj.hash) {
            //       instance++;
            //     }
            //     // // TODO iterate over the vault to increase the instance count
            //   },
            // );
          // }
          //   give each item a unique instance designator
          itemObj.instance = `V${instance}`;

          initialisedVault.push(itemObj);
      //   }
      // }
    }
    
    // console.log("ðŸš€ ~ initialisedVault:", initialisedVault)
    return initialisedVault;
  } catch (error) {
    console.log("ðŸš€ ~ parseCharacterInventory ~ error:", error);
  }
}

export default parseCharacterInventory;
